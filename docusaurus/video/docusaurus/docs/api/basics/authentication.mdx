---
id: authentication
sidebar_position: 2
slug: /authentication
title: Users & Tokens
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Creating users

Stream Users require only an ID to be created. Users can be created with the role of user or admin. The role will be set to user if a value is not provided in the request. There are additional properties you can provide to further describe your users.

The `name` and `image` fields are special fields that are supported by client-side SDKs.

You can provide additional data for the user object using the `custom` field.

<Tabs groupId="examples">
<TabItem value="js" label="JavaScript">

```js
const newUser: UserObjectRequest = {
  id: 'userid',
  role: 'user',
  custom: {
    color: 'red',
  },
  name: 'This is a test user',
  image: 'link/to/profile/image',
};
await client.upsertUsers({
  users: {
    [newUser.id]: newUser,
  },
});
```

</TabItem>
<TabItem value="py" label="Python">

```py
users = {}
users["userid"] = UserRequest(
id=user_id, role="user", custom={"color": "red"}, name="This is a test user",image: "link/to/profile/image",
)
client.upsert_users(users=users)
```

</TabItem>
</Tabs>

## Updating users

There are two ways to update user objects:

- Updating will replace the existing user object
- Partial update will let you choose which fields you want to change/unset

<Tabs groupId="examples">
<TabItem value="js" label="JavaScript">

```js
const user: UserObjectRequest = {
  id: 'userid',
  role: 'user',
  custom: {
    color: 'red',
  },
  name: 'This is a test user',
  image: 'link/to/profile/image',
};
client.upsertUsers({
  users: {
    [user.id]: user,
  },
});

// or
client.updateUsersPartial({
  users: [
    {
      id: user.id,
      set: {
        color: 'blue',
      },
      unset: ['name'],
    },
  ],
});
```

</TabItem>
</Tabs>

## Anonymous users

Anonymous users are users that are not authenticated. It's common to use this for watching a livestream or similar where you aren't authenticated. Anonymous users can be connected using client-side SDKs.

## Guest users

Guest users are temporary user accounts. You can use it to temporarily give someone a name and image when joining a call. Guest users can aslso be created client-side.

<Tabs groupId="examples">
<TabItem value="js" label="JavaScript">

```js
const guest: UserObjectRequest = {
  id: '<id>',
  name: '<name>',
  custom: {
    color: 'red',
  },
};

const guest = (await client.createGuest({ user: guest })).user;
```

</TabItem>
</Tabs>

## Deactivating and deleting users

While it is usually safer for data retention to deactivate a user, some use cases require completely deleting a user and their data.

Once a user has been deleted, it cannot be un-deleted, and the user_id cannot be used again.

<Tabs groupId="examples">
<TabItem value="js" label="JavaScript">

```js
client.deactivateUser({
  user_id: '<id>',
});

client.deleteUser({ userId: '<id>' });
```

</TabItem>
</Tabs>

## User tokens

Stream uses JWT (JSON Web Tokens) to authenticate chat users, enabling them to log in. Knowing whether a user is authorized to perform certain actions is managed separately via a role-based permissions system. Tokens need to be generated server-side.

You can optionally provide

- Expiration time. By default tokens don't have an expiration date.
- Issued at date, which is necessary if you manually want to revoke tokens. By default, the issued at date is set to the current date.

<Tabs groupId="examples">
<TabItem value="js" label="JavaScript">

```js
const userId = 'john';
// exp and iat are optional
// the token will be valid for 1hour
const exp = Math.round(new Date().getTime() / 1000) + 60 * 60;
const iat = Math.round(new Date().getTime() / 1000);
client.createToken(userId, exp, iat);
```

</TabItem>
<TabItem value="py" label="Python">

```py
import time

# user ID
user_id = 'john'

# exp and iat are optional
# the token will be valid for 1 hour
exp = int(time.time()) + 60 * 60
iat = int(time.time())

client.create_token(user_id = user_id, exp = exp, iat = iat)
```

</TabItem>
</Tabs>

## Call tokens

Call tokens contain a list of call IDs. If a user is authenticated with a call token, they can only access the specified calls.

<Tabs groupId="examples">
<TabItem value="js" label="JavaScript">

```js
const userId = 'john';
// exp and iat are optional
// the token will be valid for 1hour
const exp = Math.round(new Date().getTime() / 1000) + 60 * 60;
const iat = Math.round(new Date().getTime() / 1000);

const call_cids = ['default:call1', 'livestream:call2'];

client.createCallToken(userId, call_cids, exp, iat);
```

</TabItem>
<TabItem value="py" label="Python">

```py
import time

user_id = 'john'

# exp and iat are optional, token will be valid for 1 hour
exp = int(time.time()) + 60 * 60
iat = int(time.time())

call_cids = ['default:call1', 'livestream:call2']

client.create_token(user_id=user_id, exp, iat, call_cids)
```

</TabItem>
</Tabs>

## Provisioning token in production

Your authentication service is responsible for generating tokens for your users. It is highly recommended to always create tokens with an expiration.
All SDKs make it easy to automatically re-fetch tokens from your backend servers with token providers when they expire.
