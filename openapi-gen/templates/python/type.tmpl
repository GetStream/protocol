{{- $required := .Schema.Required}}
{{- $hasDateTime := false }}
{{- $typingImports := list}}
{{- $imports := newSet}}
{{- range $index, $value := sortedProperties .Schema}}
    {{- if and (eq .Value.Type "string") (eq .Value.Format "date-time")}}
        {{- $hasDateTime = true }}
    {{- end}}
    {{- if eq .Value.Type "array"}}
        {{- if not (contains $typingImports "List")}}
            {{- $typingImports = append $typingImports "List"}}
        {{- end}}
    {{- end}}
    {{- if and (eq .Value.Type "object") (.Value.AdditionalProperties)}}
        {{- if and (.Value.AdditionalProperties.Schema) (eq .Value.AdditionalProperties.Schema.Value.Type "array")}}
            {{- if not (contains $typingImports "List")}}
                {{- $typingImports = append $typingImports "List"}}
            {{- end}}
        {{- end}}
        {{- if and (.Value.AdditionalProperties.Schema) (not (contains $typingImports "Dict"))}}
            {{- $typingImports = append $typingImports "Dict"}}
        {{- end}}
    {{- end}}
{{- end}}

{{- if (not .Schema.Enum)}}
from dataclasses import dataclass, field
from dataclasses_json import config, dataclass_json
{{else}}
from enum import Enum
{{- end}}

{{- if .HasNonRequired}}
    {{- if not (contains $typingImports "Optional") -}}
        {{- $typingImports = append $typingImports "Optional" -}}
    {{- end}}
{{- end}}
{{- if gt (len $typingImports) 0}}
from typing import {{join $typingImports ", "}}
{{- end}}

{{- if $hasDateTime}}
from datetime import datetime
{{- end}}
{{- if (gt (len .Schema.OneOf) 0)}}
from typing import Union
from json import loads
{{else}}

{{- end}}


{{- range $i, $ref := .References}}
    {{- $refName := refToName $ref | toCamel}}
    {{- if not ($imports.Contains $refName)}}
        {{- $_ := $imports.Add $refName}}
from {{with index additionalParameters "modelImportPrefix"}}{{.}}{{else}}models.{{end}}models.{{refToName $ref | toSnake}} import {{refToName $ref | toCamel}}
    {{- end -}}
{{- end -}}

{{- define "generateType" -}}
{{- if (eq .Type "string")}}
    {{- if (eq .Format "date-time") -}}datetime{{- else -}}str{{- end -}}
{{- end -}}
{{- if (eq .Type "integer")}}int{{end}}
{{- if (eq .Type "number")}}float{{end}}
{{- if (eq .Type "boolean")}}bool{{end}}
{{- if (eq .Type "array")}}List[{{template "generateSchemaRef" .Items -}}]{{end}}
{{- if (eq .Type "object")}}{{with .AdditionalProperties}}Dict[str, {{template "generateSchemaRef" .Schema -}}]{{end}}{{end}}
{{- if (eq .Type "null")}}None{{end}}
{{- if (eq .Type "")}}object{{end}}
{{- end -}}

{{- define "generateSchemaRef" -}}
{{- if .}}
{{- if (eq .Ref "") -}}{{- template "generateType" .Value -}}{{- else -}}{{refToName .Ref | toCamel}}{{- end -}}
{{- end -}}
{{- end}}

{{- with .Schema.Discriminator}}
mapping = {
    {{- range $key, $one := .Mapping}}
    "{{$key}}": {{refToName $one | toCamel}},
    {{- end}}
}

{{else}}
{{- if (not .Schema.Enum)}}
@dataclass_json
{{- end}}
{{end -}}
{{- if (not .Schema.Enum)}}
@dataclass
{{- end}}
class {{toCamel .Name}}{{- if .Schema.Enum}}(Enum){{end}}:
    {{- if (gt (len .Schema.Properties) 0)}} 
    {{- $required := .Schema.Required}}
    {{- range $index, $value := sortedProperties .Schema}}
    {{toSnake $value.Name}}: {{if and $value.Required $value.SchemaRef -}} {{template "generateSchemaRef" $value.SchemaRef}} = field(metadata=config(field_name="{{$value.Name}}")) {{- else -}} Optional[{{template "generateSchemaRef" $value.SchemaRef}}] = field(metadata=config(field_name="{{$value.Name}}"), default=None) {{- end -}}
    {{- end}}
    {{else if (gt (len .Schema.OneOf) 0)}}
    event : Union[
    {{- range $i, $one := .Schema.OneOf}}
        {{- if (gt $i 0)}},{{end}}
        {{template "generateSchemaRef" $one}}
    {{- end}}
    ]

    @classmethod
    def from_json(j) -> '{{toCamel .Name}}':
        dict_type = loads(j)["{{.Schema.Discriminator.PropertyName}}"]
        return {{toCamel .Name}}(event=mapping[dict_type].from_json(j))
    {{- else}}
    
{{- if .Schema.Enum}}
    {{- range $index, $value := .Schema.Enum}}
    {{toConstant $value}} = "{{$value}}"
    {{- end}}
    
    @classmethod
    def from_str(cls, value: str) -> "{{toCamel .Name}}":
        try:
            return cls(value)
        except ValueError:
            raise ValueError(f"'{value}' is not a valid {{toCamel .Name}}")
{{- end}}

    {{- end}}

